#pragma once
#include "core/lite_mem_stream.h"
#include "control_flow_graph.h"

#include <unordered_map>
#include <functional>

namespace pfm::trampoline 
{
    using AddressMap = std::unordered_map<uint8_t*, uint8_t*>;
    using CodegenFunc = std::function<void(const AddressMap&)>;

    inline uint8_t* mapped_addr(const AddressMap& map, uint8_t* addr) {
        auto it = map.find(addr);
        return it == map.end() ? addr : it->second;
    }

    /// Result of a code relocation operation. Provides a map of old instruction addresses to new ones.
    struct RelocResult {
        bool success;
        AddressMap address_map;

        operator bool() { return success; }
    };

    /// Relocates `code_block` into the `mem_stream`. `ip` is the IP at the start of the code block, 
    /// or `code_block.data()` if not provided. 
    RelocResult relocate(LiteMemStream& mem_stream, std::span<uint8_t> code_block, std::optional<uint8_t*> ip = std::nullopt);

    /// Generates a trampoline at `insert_pos` to code generated by `codegen` into the `arena`.
    /// If `replace` is true, will replace the instruction at `insert_pos` instead of relocating it.
    /// If a CFG is provided, will attempt to fix jump targets as well. CFG analysis must have already taken place.
    RelocResult gen_trampoline(LiteMemStream& arena, CodegenFunc codegen, uint8_t* insert_pos, bool replace = false, CFG* cfg = nullptr, AddressMap* old_map = nullptr);

    /// Generates a trampoline at `insert_pos` to code generated by `codegen` into the `arena`.
    /// If `replace` is true, will replace the instruction at `insert_pos` instead of relocating it.
    /// If a CFG is provided, will attempt to fix jump targets as well. CFG analysis must have already taken place.
    inline RelocResult gen_trampoline(LiteMemStream& arena, std::function<void()> codegen, uint8_t* insert_pos, bool replace = false, CFG* cfg = nullptr) {
        return gen_trampoline(arena, [&codegen](const AddressMap& _) { codegen(); }, insert_pos, replace, cfg);
    }
}